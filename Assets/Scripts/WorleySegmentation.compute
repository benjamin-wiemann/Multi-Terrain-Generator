// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel CSMain

// Create a RenderTexture with enableRandomWrite flag and set it
// with cs.SetTexture
RWTexture2D<float4> Result;

[numthreads(8,8,1)]
void CSMain (uint3 id : SV_DispatchThreadID)
{
    // TODO: insert actual code here!

    Result[id.xy] = float4(id.x & id.y, (id.x & 15)/15.0, (id.y & 15)/15.0, 0.0);
}

// 2-component hash function borrowed from Inigo Quilez's
// "Voronoi - smooth" ShaderToy demo:
// https://www.shadertoy.com/view/ldB3zc
float2 hash2(float2 p)
{
    p = float2(dot(p, float2(127.1f, 311.7f)),
                            dot(p, float2(269.5f, 183.3f)));
    return frac(sin(p) * 43758.5453f);
}

float worley(float2 p)
{
    // Which integer grid cell are we in?
    float2 cell = floor(p);
    // Where are we within that cell [0-1)?
    float2 inCell = p - cell;

    // Farthest a point can be from closest seed point
    // is one square diagonal, which is sqrt(2) away.
    float smallestSquared = 2.0f;
    // Iterate over the 3x3 block of nearby grid cells. 
    for (int x = -1; x <= 1; x++)
    {
        for (int y = -1; y <= 1; y++)
        {
            // Compute the position of the seed point in that cell
            // relative to this cell.
            float2 shift = float2(x, y);
            float2 seed = hash2(cell + shift) + shift;

            // Compute distance from sample point to the seed point.
            float2 sampleToSeed = seed - inCell;
            float squaredDistance = dot(sampleToSeed, sampleToSeed);

            // Keep the smallest squared distance.
            smallestSquared = min(smallestSquared,
                                              squaredDistance);
        }
    }
                
    // Normalize so farthest possible distance is 1,
    // and square root to get linear length.
    return sqrt(smallestSquared / 2.0f);
}